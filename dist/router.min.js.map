{"version":3,"file":"router.min.js","sources":["../src/index.ts"],"sourcesContent":["type Parsed = [ RegExp, string[] ]\n\n// Parses a URL pattern such as `/users/:id`\n// and builds and returns a regex that can be used to\n// match said pattern. Credit for these\n// regexes belongs to Jeremy Ashkenas and the\n// other maintainers of Backbone.js\n//\n// It has been modified for extraction of\n// named paramaters from the URL\nconst parse = (pattern: string): Parsed => {\n    const names: string[] = []\n\n    // regexes borrowed from backbone\n    pattern = pattern\n        // escapeRegExp\n        .replace(/[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g, '\\\\$&')\n        // optional param\n        .replace(/\\((.*?)\\)/g, '(?:$1)?')\n        // named param\n        .replace(/(\\(\\?)?:\\w+/g, (match, optional) => {\n            names.push(match.slice(1))\n            return optional ? match : '([^/?]+)'\n        })\n        // splatParam\n        .replace(/\\*/g, () => {\n            names.push('path')\n            return '([^?]*?)'\n        })\n\n    return [ new RegExp('^' + pattern + '(?:\\\\?([\\\\s\\\\S]*))?$'), names ]\n}\n\nexport default (routes: { [path: string]: any }, fallback: any = null) => {\n    // loop through each route we're\n    // and build the shell of our\n    // route cache.\n    const patterns = Object.keys(routes).map(pattern => ({\n        // ...parsePattern(pattern),\n        page: routes[pattern],\n        pattern,\n    }))\n\n    const cache: Parsed[] = []\n\n    // main result is a function that can be called\n    // with the url\n    return (url: string) => {\n        for (let i = 0; i < patterns.length; i++) {\n            const route = patterns[i]\n\n            let parsed = cache[i]\n            if (!parsed) {\n                parsed = parse(route.pattern)\n                cache[i] = parsed\n            }\n\n            const match = parsed[0].exec(url)\n\n            if (match) {\n                const result = match.slice(1, -1)\n\n                // reduce our match to an object of named paramaters\n                // we've extracted from the url\n                const params = result.reduce((obj, val, index) => {\n                    if (val) {\n                        obj[parsed[1][index]] = val\n                    }\n                    return obj\n                }, {})\n\n                return {\n                    ...route,\n                    url,\n                    params,\n                }\n            }\n        }\n\n        return fallback && {\n            url,\n            page: fallback,\n        }\n    }\n}\n"],"names":["parse","pattern","names","replace","match","optional","push","slice","RegExp","routes","fallback","patterns","Object","keys","map","page","cache","url","i","length","route","parsed","exec","params","reduce","obj","val","index"],"mappings":"AAUA,MAAMA,EAASC,IACX,MAAMC,EAAkB;AAmBxB,OAhBAD,EAAUA,EAELE,QAAQ,2BAA4B,QAEpCA,QAAQ,aAAc,WAEtBA,QAAQ,eAAgB,CAACC,EAAOC,KAC7BH,EAAMI,KAAKF,EAAMG,MAAM,IAChBF,EAAWD,EAAQ,aAG7BD,QAAQ,MAAO,KACZD,EAAMI,KAAK,QACJ,aAGR,CAAME,OAAO,IAAMP,EAAU,wBAAyBC;cAGlD,CAACO,EAAiCC,EAAgB,QAI7D,MAAMC,EAAWC,OAAOC,KAAKJ,GAAQK,IAAIb,KAErCc,KAAMN,EAAOR,GACbA,QAAAA,KAGEe,EAAkB;AAIxB,OAAQC,IACJ,IAAK,IAAIC,EAAI,EAAGA,EAAIP,EAASQ,OAAQD,IAAK,CACtC,MAAME,EAAQT,EAASO;AAEvB,IAAIG,EAASL,EAAME;AACdG,IACDA,EAASrB,EAAMoB,EAAMnB,SACrBe,EAAME,GAAKG;AAGf,MAAMjB,EAAQiB,EAAO,GAAGC,KAAKL;AAE7B,GAAIb,EAAO,CACP,MAIMmB,EAJSnB,EAAMG,MAAM,GAAI,GAITiB,OAAO,CAACC,EAAKC,EAAKC,KAChCD,IACAD,EAAIJ,EAAO,GAAGM,IAAUD,GAErBD,GACR;AAEH,MAAO,IACAL,EACHH,IAAAA,EACAM,OAAAA,IAKZ,OAAOb,GAAY,CACfO,IAAAA,EACAF,KAAML"}